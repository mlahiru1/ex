pascal_element(_, 1, 1).  % First element is 1
pascal_element(R, N, 1) :- N is R.  % Last element is 1

pascal_element(R, N, Value) :-
    R > 1,
    N > 1,
    N < R,
    R1 is R - 1,
    N1 is N - 1,
    N2 is N,
    pascal_element(R1, N1, Value1),
    pascal_element(R1, N2, Value2),
    Value is Value1 + Value2.

























%
print_spaces(0).
print_spaces(N) :-
    N > 0,
    write('  '),
    N1 is N - 1,
    print_spaces(N1).

print_row(_, 0, _).
print_row(R, N, Spaces) :-
    N > 0,
    pascal_element(R, N, Value),
    print_spaces(Spaces),
    write(Value),
    N1 is N - 1,
    print_row(R, N1, Spaces).

pascal_triangle(0).
pascal_triangle(R) :-
    R > 0,
    R1 is R - 1,
    pascal_triangle(R1),
    nl,
    InitialSpaces is 10-(R1),  % Adjust spacing for alignment
    print_spaces(InitialSpaces),
    print_row(R, R, 2).  % Space between numbers
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

%reverse
addtoend(H, [], [H]).
addtoend(H, [X|T], [X|T1]) :- addtoend(H, T, T1).

reversex([], []). % Base case: Empty list.
reversex([H|T], Y) :-
    reversex(T, T1), 
    addtoend(H, T1, Y). % Add the head to the reversed tail.
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
3. Create a List in a Range
Generate a list of integers from `A` to `X`:
```prolog
create_list(X, X, [X]). % Base case: Single element list.
create_list(A, X, [A|T]) :-
    A < X, 
    A1 is A + 1,
    create_list(A1, X, T).
```
Query Example:
```prolog
?- create_list(5, 12, S).
% Output: S = [5, 6, 7, 8, 9, 10, 11, 12].
```





































% append
list_number(X,[X|_]).
list_member(X,[_|TAIL]) :- list_member(X,TAIL).
list_append(A,T,T) :- list_member(A,T),!.
list_append(A,T,[A|T]).

































%concat
list_concat([],L,L).
list_concat([X1|L1],L2,[X1|L3]) :- list_concat(L1,L2,L3).









































%list Delete
list_delete(X,[X],[]).
list_delete(X,[X|L1],L1).
list_delete(X,[Y|L2],[Y|L1]) :- list_delete(X,L2,L1).






































%insert
list_delete(X,[X],[]).
list_delete(X,[X|L1],L1).
list_delete(X,[Y|L2],[Y|L1]) :- list_delete(X,L2,L1).
list_insert(X,L,R) :- list_delete(X,R,L).






































%intersection
list_member(X,[X|_]). 
list_member(X,[_|TAIL]) :- list_member(X,TAIL). 
list_intersect([X|Y],Z,[X|W]) :- list_member(X,Z), list_intersect(Y,Z,W). 
list_intersect([X|Y],Z,W) :- \+ list_member(X,Z), list_intersect(Y,Z,W). 
list_intersect([],Z,[]).






































% union
list_member(X,[X|_]). 
list_member(X,[_|TAIL]) :- list_member(X,TAIL). 
list_union([X|Y],Z,W) :- list_member(X,Z),list_union(Y,Z,W). 
list_union([X|Y],Z,[X|W]) :- \+ list_member(X,Z), list_union(Y,Z,W). 
list_union([],Z,Z).








































4. Mean of a List
Compute the mean value of a list:
```prolog
sum_list([], 0, 0). % Base case: Length and sum are zero for an empty list.
sum_list([H|T], Length, Sum) :-
    sum_list(T, L1, S1),
    Length is L1 + 1,
    Sum is S1 + H.

mean(L, M) :-
    sum_list(L, Length, Sum),
    Length > 0, % Ensure the list is not empty to avoid division by zero.
    M is Sum / Length.
```
Query Example:
```prolog
?- mean([1,2,3,4,5], M).
% Output: M = 3.
```










































% max
max_of_two(X,Y,X) :- X >= Y. 
max_of_two(X,Y,Y) :- X < Y. 
list_max_elem([X],X). 
list_max_elem([X,Y|Rest],Max) :-
list_max_elem([Y|Rest],MaxRest), 
max_of_two(X,MaxRest,Max).





































%merge sort
mergesort([],[]).
mergesort([A],[A]). 
mergesort([A,B|R],S) :- split([A,B|R],L1,L2),mergesort(L1,S1),mergesort(L2,S2), merge(S1,S2,S). 

split([],[],[]). 
split([A],[A],[]). 
split([A,B|R],[A|Ra],[B|Rb]) :-split(R,Ra,Rb). 

merge(A,[],A). 
merge([],B,B). 
merge([A|Ra],[B|Rb],[A|M]) :- A =< B, merge(Ra,[B|Rb],M). 
merge([A|Ra],[B|Rb],[B|M]) :- A > B, merge([A|Ra],Rb,M).






































% orderd list
list_order([X]).
list_order([X, Y | Tail]) :- X =< Y, list_order([Y|Tail]).








































%permutation 
list_delete(X,[X|L1],L1).
list_delete(X,[Y|L2],[Y|L1]) :- list_delete(X,L2,L1).
list_perm([],[]).
list_perm(L,[X|P]) :- list_delete(X,L,L1),list_perm(L1,P).












































% shift
list_concat([],L,L). 
list_concat([X1|L1],L2,[X1|L3]) :- list_concat(L1,L2,L3). 
list_shift([Head|Tail],Shifted) :- list_concat(Tail, [Head],Shifted).







































%subset
list_subset([],[]). 
list_subset([Head|Tail],[Head|Subset]) :- list_subset(Tail,Subset). 
list_subset([Head|Tail],Subset) :- list_subset(Tail,Subset).





































%list sum
list_sum([],0). 
list_sum([Head|Tail], Sum) :- list_sum(Tail,SumTemp), Sum is Head + SumTemp.





































%Acending Ordered List (aOL)of a given list L is given by OL.
aOL([X],[X]):-!.
aOL(L,OL):-smallest(X,L),del(X,L,L1),aOL(L1,L2),OL=[X|L2].





































%Bubble Sort
bbs(L,SL):-swap(L,L1),!,bbs(L1,SL).
bbs(S,S).
swap([X,Y|R],[Y,X|R]):-gt(X,Y).
swap([Z|R],[Z|R1]):-swap(R,R1).
gt(X,Y):-X>Y.







































% Insertion sort
ins([],[]).
ins([X|T],SL):-ins(T,ST),insert(X,ST,SL).
insert(X,[Y|SL],[Y|SL1]):-gt(X,Y),!,insert(X,SL,SL1).
insert(X,SL,[X|SL]).







































% Quick sort
qs([],[]).
qs([X|T],SL):-split(X,T,Small,Big),qs(Small,SS),qs(Big,SB),conc(SS,[X|SB],SL). 
split(X,[],[],[]).
split(X,[Y|T],[Y|Small],Big):- gt(X,Y),!,split(X,T,Small,Big).
split(X,[Y|T],Small,[Y|Big]):-split(X,T,Small,Big).







































%MergeSort by divide and merge
mergesort([],[]):-!.
mergesort([X],[X]):-!.
mergesort(L,SL):-
divide(L,L1,L2),mergesort(L1,SL1),mergesort(L2,SL2),merge(SL1,SL2,SL).
divide([],[],[]):-!.
divide([X],[X],[]):-!.
divide([X,Y|L],[X|L1],[Y|L2]):-divide(L,L1,L2).
merge([],L,L):-!.
merge(L,[],L):-!.
merge([X|R1],[Y|R2],[X|R3]):-X<Y,!,merge(R1,[Y|R2],R3).
merge(L1,[Y|R2],[Y|R3]):-merge(L1,R2,R3)




































printStarLine(0) :- !.					
printStarLine(N) :- N > 0, write('* '), N1 is N-1, printStarLine(N1).

printStarsMatrix :- 
    write('Number of rows: '), read(R),
    write('Number of columns: '), read(C),
    print_rows(R, C).

print_rows(0, _) :- !.  
print_rows(R, C) :-
				print_columns(C), nl,                     
				R1 is R - 1, print_rows(R1, C).      

print_columns(0) :- !.      
print_columns(C) :- write('* '), C1 is C - 1, print_columns(C1).  


printStarLine1(0) :- !. 
printStarLine1(N) :- write('* '), N1 is N-1, printStarLine1(N1).

printPattern1(0) :- !.    
printPattern1(N) :- 
				tab(80), printStarLine1(N), nl,  
				N1 is N-1, printPattern1(N1).


printStarLine2(0) :- !.
printStarLine2(N) :- write('*'), N1 is N - 1, printStarLine2(N1).    
printPattern2(N) :-
				N > 0, R is 50 - N, tab(R), printStarLine2(N), nl,
				N1 is N - 1, printPattern2(N1).



printStarLine3(0) :- !.
printStarLine3(N) :- write('* '), N1 is N - 1, printStarLine3(N1).

printPattern3(L, M) :- L > M, !.
printPattern3(L, M) :-
    L > 0, printStarLine3(L), nl, 
    L1 is L + 1, printPattern3(L1, M).


printStarLine4(0) :- !.
printStarLine4(N) :- write('* '), N1 is N - 1, printStarLine4(N1).    
printPattern4(N) :-
				N > 0, R is 50 - N, tab(R), printStarLine4(N), nl,
				N1 is N - 1, printPattern4(N1).
	

printStarLine5(0) :- !.
printStarLine5(N) :- write('* '), N1 is N - 1, printStarLine5(N1).    
printPattern5(L, M) :-
				L > 0, L =< M, R is 50 - L, tab(R), printStarLine5(L), nl,
				L1 is L + 1, printPattern5(L1, M).



printStarLine6(0) :- !.
printStarLine6(N) :- write('*'), N1 is N - 1, printStarLine6(N1).
printPattern6(S, L, M) :-
				L =< M, SS is 50 - S, tab(SS), N is 2*L - 1, printStarLine6(N), nl,
				L1 is L + 1, 
				SS1 is S + 1, 
				printPattern6(SS1, L1, M). 


printStarLine7(0) :- !.
printStarLine7(N) :- N > 0, write('*'), N1 is N - 1, printStarLine7(N1).
printPattern7(S, L, M) :-
    L =< M, SS is 50 - S, tab(SS), 
	N is 2 * (M - L + 1) - 1, % Calculate the number of stars to print (decreasing by 2 each row)
    printStarLine7(N), nl,
    L1 is L + 1, 
	SS1 is S - 1,
    printPattern7(SS1, L1, M). 

